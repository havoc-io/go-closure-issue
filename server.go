package rsync

import (
	"io"
	"os"

	"bitbucket.org/kardianos/rsync"
)

type Server struct {
	root    string
	stream  *Stream
	rsyncer *rsync.RSync
}

func NewServer(root string, connection io.ReadWriteCloser) *Server {
	return &Server{
		root:    root,
		stream:  newStream(connection),
		rsyncer: newRsyncer(),
	}
}

func (s *Server) serveOne() error {
	// Read the next request.
	var request request
	if err := s.stream.Decode(&request); err != nil {
		return err
	}

	// Open the target file and ensure its cleanup. If we can't open it, then
	// it's probably due to a concurrent modification, but this isn't a terminal
	// error, so just abort this transmission.
	target, err := os.Open(request.Path.AppendedToRoot(s.root))
	if err != nil {
		// Tell the client that this stream is done. If that fails, then it IS
		// actually a problem.
		if err := s.stream.Encode(response{Done: true}); err != nil {
			return err
		}

		// Done.
		return nil
	}
	defer target.Close()

	// Create an operation writer. Track any errors that arise from encoding
	// responses, because those are terminal.
	var encodeError error
	writer := func(o rsync.Operation) error {
		encodeError = s.stream.Encode(response{Operation: o})
		return encodeError
	}

	// Perform the delta generation and streaming. We don't check for errors
	// here because we only care about errors generated by transmission (which
	// are tracked separately). Any other errors are due to the source file and
	// can occur regularly due to concurrent modification.
	s.rsyncer.CreateDelta(target, request.BaseSignature, writer, nil)
	writer = nil

	// If there's an encoding error, return it.
	if encodeError != nil {
		return err
	}

	// Notify the client that the stream is done.
	if err := s.stream.Encode(response{Done: true}); err != nil {
		return err
	}

	// Success.
	return nil
}

func (s *Server) Serve() error {
	// Serve requests until a terminal error occurs.
	for {
		if err := s.serveOne(); err != nil {
			return err
		}
	}
}

func (s *Server) Close() error {
	return s.stream.Close()
}
